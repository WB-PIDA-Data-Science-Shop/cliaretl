################################################################################
############### SOME FUNCTIONS FOR DATA PIPELINE MANAGEMENT ####################
################################################################################


#' Add Metadata Attributes to a Dataset
#'
#' Adds metadata to a `data.frame`, such as the source URL, download date, and any additional information.
#'
#' @param df A `data.frame` object to which metadata will be added.
#' @param source A `character` string indicating the URL or source of the dataset.
#' @param other_info A `character` string containing any additional metadata or descriptive information.
#'
#' @return The input `data.frame` with additional attributes:
#' \describe{
#'   \item{`source`}{The URL or source location of the dataset.}
#'   \item{`other info`}{Any user-supplied contextual information.}
#'   \item{`download_date`}{The date when the data was processed or downloaded.}
#' }
#'
#' @examples
#' df <- data.frame(x = 1:5)
#' df_meta <- add_plmetadata(df,
#'                           source = "https://example.com/data.csv",
#'                           other_info = "Mock dataset for demo")
#' attributes(df_meta)
#'
#' @export
add_plmetadata <- function(df,
                           source,
                           other_info) {
  attr(df, "source") <- source
  attr(df, "other_info") <- other_info
  attr(df, "latest_download") <- Sys.Date()

  return(df)

}


#' Collect metadata from all datasets in the package data folder
#'
#' @param data_path Path to the `data/` folder (default = "data").
#'
#' @return A data frame with metadata for each dataset in the package.
#'
#' @importFrom purrr map_dfr
#' @importFrom rlang %||%
#' @importFrom tibble tibble
#' @export
collect_metadata <- function(data_path = "data") {

  df <-
  list.files(data_path,
             pattern = "\\.rda$",
             full.names = TRUE) |>
    map_dfr(function(file_path) {
      env <- new.env()
      load(file_path, envir = env)

      obj_name <- ls(env)[1]
      obj <- env[[obj_name]]

      tibble::tibble(
        dataset = obj_name,
        source = attr(obj, "source") %||% NA_character_,
        other_info = attr(obj, "other_info") %||% NA_character_,
        latest_download = as.character(attr(obj, "latest_download") %||% NA)
      )
    })

  return(df)

}


#' Flag Mismatched Indicators to Dictionary
#'
#' Identifies variable names in a data frame that are not included in a reference dictionary of valid indicators `db_variables`.
#'
#' @param df A data frame containing extracted indicators along with identifying columns such as `country_code`, `country_name`, and `year`.
#' @param dictionary A data frame containing a column named `variable` with the list of valid variable names.
#'
#' @return A named list containing a tibble with one column, `variable`, listing the mismatched variables found in `df` but not in `db_variables$variable`.
#' The name of the element in the list is generated by appending `_mismatched_vars` to the original name of the `df` object.
#' @export
flag_mismatched_indicators <- function(df, dictionary) {
  # Load required package
  requireNamespace("tibble", quietly = TRUE)

  # Capture the name of the input data frame
  df_name <- deparse(substitute(df))

  # Exclude identifier variables
  df_vars <- setdiff(names(df), c("country_code", "country_name", "year"))

  # Identify mismatched and missing variable names
  mismatched <- setdiff(df_vars, dictionary$variable)

  # Create tibble of mismatches
  mismatched_df <- tibble::tibble(variable = mismatched)

  # Create named list
  result_name <- paste0(df_name, "_mismatched_vars")
  result <- list()
  result[[result_name]] <- mismatched_df

  return(result)
}

#' Flag Missing Indicators Compared to Dictionary
#'
#' Identifies variables that are in the dictionary (`db_variables`) but missing from the given data frame.
#' This function offers flexibility by allowing the user to specify the column in `db_variables` that contains
#' the source information, which can be different from the default "source" column.
#'
#' @param dictionary A data frame containing a column named `variable` with the list of valid variable names.
#'   It can also contain a column (specified by `source_colname`) with source information.
#' @param df A data frame containing extracted indicators along with identifying columns such as `country_code`, `country_name`, and `year`.
#' @param source_type Optional. A character string specifying the source to filter the dictionary (e.g., "WDI").
#'   If provided, only variables associated with this source type will be considered from `db_variables`.
#' @param source_colname Optional. A character string specifying the name of the column in `db_variables`
#'   that contains the source information. Defaults to `"source"`. This allows for flexibility if the source
#'   column is named differently (e.g., `"etl_source"`).
#'
#' @return A tibble with one column, `variable`, listing the variables from `db_variables` that are missing in `df`.
#'
#' @export
flag_missing_indicators <- function(dictionary, df, source_type = NULL, source_colname = "source") {
  requireNamespace("tibble", quietly = TRUE)
  requireNamespace("dplyr", quietly = TRUE)

  # Filter dictionary if source_type is provided and source_colname exists
  dictionary <- if (!is.null(source_type) && source_colname %in% colnames(dictionary)) {
    dictionary |>
      dplyr::filter(.data[[source_colname]] == source_type) |>
      dplyr::pull(variable)
  } else {
    # If source_type is not provided or source_colname doesn't exist, use all variables
    dictionary |>
      dplyr::pull(variable)
  }

  df_name <- deparse(substitute(df))
  df_vars <- setdiff(colnames(df), c("country_code", "country_name", "year"))
  missing <- setdiff(dictionary, df_vars)

  missing_df <- tibble::tibble(variable = missing)

  return(missing_df)
}


#' Update Variable Names in db_variables
#'
#' This function efficiently renames multiple entries within a specified column
#' of a provided data frame using a named vector of `new_name = old_name` pairs.
#' It also allows for finding a specific variable's index for manual edits.
#'
#' @param data A data frame containing the target column for renaming.
#' @param rename_map A named character vector (e.g., `c("new_var" = "old_var")`).
#'   If `NULL`, no bulk renaming is applied.
#' @param column_name A character string specifying which column to apply the
#'   renaming to. Defaults to "variable" for backward compatibility.
#' @param find_var_name An optional character string. If provided, the function
#'   will return the row index of this value in the specified column after any renames.
#' @return The modified data frame if `find_var_name` is `NULL`.
#'   If `find_var_name` is provided, returns the numeric row index of the first
#'   match, or `NA` if not found.
#'
#' @examples
#' \dontrun{
#' # Example 1: Apply bulk renames to 'var_name' column
#' rename_map <- c("New Variable A" = "Old Variable A")
#' data_updated <- update_db_variables(data, rename_map = rename_map, column_name = "var_name")
#'
#' # Example 2: Apply bulk renames to 'description' column
#' desc_renames <- c("Updated description" = "Old description")
#' data_updated <- update_db_variables(data, rename_map = desc_renames, column_name = "description")
#' }
#'
#' @export
update_db_variables <- function(data,
                                rename_map = NULL,
                                column_name = "variable",
                                find_var_name = NULL) {
  # Input validation
  if (!is.data.frame(data)) {
    stop("`data` must be a data frame.")
  }

  if (!is.character(column_name) || length(column_name) != 1) {
    stop("`column_name` must be a single character string.")
  }

  if (!column_name %in% names(data)) {
    stop(paste0("The provided data frame must contain a '", column_name, "' column."))
  }

  # Apply bulk renaming if rename_map is provided
  if (!is.null(rename_map)) {
    if (!is.character(rename_map) || is.null(names(rename_map))) {
      stop("`rename_map` must be a named character vector (e.g., c('new' = 'old')).")
    }

    # Apply renaming to the specified column
    match_idx <- match(data[[column_name]], unname(rename_map))
    data[[column_name]][!is.na(match_idx)] <- names(rename_map)[na.omit(match_idx)]

    message(paste0("Renaming applied to the '", column_name, "' column."))
  }

  # Find and return index if find_var_name is provided
  if (!is.null(find_var_name)) {
    if (!is.character(find_var_name) || length(find_var_name) != 1) {
      stop("`find_var_name` must be a single character string.")
    }

    idx <- which(data[[column_name]] == find_var_name)
    if (length(idx) > 0) {
      return(idx[1]) # Return first match
    } else {
      return(NA_integer_) # No match
    }
  }

  return(data) # Return the modified data frame by default
}

#' Add New Rows to db_variables Metadata (with feedback)
#'
#' Appends new variable metadata rows to an existing `db_variables`
#' data frame after checking column compatibility and reports which
#' new unique values were introduced in each column.
#'
#' @param db_variables A data frame representing the existing metadata.
#' @param new_rows A data frame or tibble with the same column names
#'   as `db_variables`, representing new entries to append.
#' @param validate Logical; if TRUE (default), checks that `new_rows`
#'   columns match `db_variables` columns before binding.
#' @param order_by character; a variable name inside `db_variables` to
#' order the final output, default set to the `variable` column (as is
#' the existing norm)
#'
#' @return An updated `db_variables` data frame containing the new rows.
#'
#' @importFrom dplyr bind_rows arrange all_of
#' @importFrom purrr map keep walk
#' @importFrom glue glue
#'
#' @examples
#' new_entries <- tibble::tibble(
#'   var_name = "New indicator example",
#'   api_id = NA_character_,
#'   variable = "bs_new_001",
#'   var_level = "indicator",
#'   family_var = "vars_newfamily",
#'   family_name = "New Family",
#'   family_order = 20,
#'   processing = NA_character_,
#'   description = "A newly added test indicator",
#'   description_short = "Short description",
#'   source = "Internal",
#'   benchmarked_ctf = "No",
#'   benchmark_static_family_aggregate_download = NA_character_,
#'   benchmark_dynamic_indicator = NA_character_,
#'   benchmark_dynamic_family_aggregate = NA_character_,
#'   rank_id = NA_real_,
#'   etl_source = "manual"
#' )
#'
#' db_variables <- addnew_db_variables(db_variables, new_entries)
#' @export
addnew_db_variables <- function(db_variables,
                                new_rows,
                                validate = TRUE,
                                order_by = "variable") {

  ## ensure both db_variables and new_rows are dataframes
  stopifnot(is.data.frame(db_variables), is.data.frame(new_rows))

  if (validate) {
    ## ensure we dont have missing variables and warn about extra columns
    missing_cols <- setdiff(names(db_variables), names(new_rows))
    extra_cols <- setdiff(names(new_rows), names(db_variables))

    if (length(missing_cols) > 0) {
      stop(glue::glue(
        "Missing columns in new_rows: {paste(missing_cols, collapse = ', ')}"
      ), call. = FALSE)
    }

    if (length(extra_cols) > 0) {
      warning(glue::glue(
        "Extra columns in new_rows ignored: {paste(extra_cols, collapse = ', ')}"
      ))
      new_rows <- new_rows[names(db_variables)]
    }

    new_rows <- new_rows[names(db_variables)]
  }

  # ---- Identify newly introduced values ----
  col_diffs <- purrr::map(names(db_variables), function(col) {
    old_vals <- unique(stats::na.omit(db_variables[[col]]))
    new_vals <- unique(stats::na.omit(new_rows[[col]]))
    setdiff(new_vals, old_vals)
  })
  names(col_diffs) <- names(db_variables)

  new_info <- purrr::keep(col_diffs, ~ length(.x) > 0)

  if (length(new_info) > 0) {
    message(glue::glue("New unique values introduced in:"))
    purrr::walk(names(new_info), function(col) {
      vals <- paste(new_info[[col]], collapse = ", ")
      message(glue::glue("{col}: {vals}"))
    })
  } else {
    message("No new unique values introduced; all entries align with existing metadata.")
  }


  result_tbl <-
    dplyr::bind_rows(db_variables, new_rows) |>
    dplyr::arrange(dplyr::all_of(order_by)) |>
    unique()

  # ---- Bind and return ----
  return(result_tbl)

}



#' Scale Values to [0, 1] Range
#'
#' This function rescales a numeric vector to the zero to unit range using
#' min-max normalization. Missing values (`NA`) are ignored
#' when computing the minimum and maximum.
#'
#' @param x A numeric vector to be scaled.
#'
#' @return A numeric vector where all non-missing values are
#' rescaled to the range [0, 1]. If all elements of `x` are `NA`,
#' the result will be `NA`.
#'
#' @examples
#' scale_values(c(1, 2, 3, 4, 5))
#' # Returns: 0.00 0.25 0.50 0.75 1.00
#'
#' scale_values(c(10, 20, NA, 30))
#' # Returns: 0.00 0.50   NA  1.00
#'
#' @export
scale_values <- function(x){
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}


#' Compare Variable Values Between CLIAR Pipelines Using Pointblank
#'
#' @param old_df Data frame from the previous pipeline (gold standard)
#' @param new_df Data frame from the new pipeline
#'
#' @return A summary tibble and a printed pointblank agent
#' @export
#'
#' @import dplyr tidyr pointblank
#' @importFrom stats median na.omit
#'
#' @examples
#' # Create example old and new datasets
#' set.seed(123)
#' old_df <- data.frame(
#'   country_code = rep(c("USA", "KEN", "NGA"), each = 2),
#'   year = rep(2020:2021, 3),
#'   gdp = c(50000, 52000, 1800, 1900, 2400, 2600),
#'   population = c(330e6, 331e6, 53e6, 54e6, 206e6, 208e6)
#' )
#'
#' new_df <- data.frame(
#'   country_code = rep(c("USA", "KEN", "NGA"), each = 2),
#'   year = rep(2020:2021, 3),
#'   gdp = c(50500, 52200, 1850, 1950, 2450, 2650),  # small changes
#'   population = c(330e6, 331e6, 53e6, 54.1e6, 206e6, 208.5e6)  # small changes
#' )
#'
#' # Run quality check
#' results <- qualitycheck_plvalue(old_df, new_df)
#'
#' # View summary
#' results$summary
#'
#' # Export a single agent report (optional)
#' # pointblank::export_report(results$agents[[1]], filename = "example_qc_report.html")
#'
qualitycheck_plvalue <- function(old_df,
                                 new_df) {

  common_vars <- intersect(names(old_df), names(new_df))

  check_list <-
    lapply(common_vars,
           function(var) {

            old_df <-
              old_df |>
              dplyr::select(country_code, year, !!sym(var)) |>
              na.omit()

            country_list <- unique(old_df[["country_code"]])
            year_list <- unique(old_df[["year"]])


            new_df <-
              new_df |>
              dplyr::select(country_code, year, !!sym(var)) |>
              dplyr::filter(country_code %in% country_list &
                              year %in% year_list)

            old_col <- old_df[[var]]
            new_col <- new_df[[var]]

            # Ensure comparable numeric values
            if (is.numeric(old_col) && is.numeric(new_col)) {
              tibble(
                variable = var,
                old_class = class(old_col)[1],
                new_class = class(new_col)[1],
                type_equal = class(old_col)[1] != class(new_col)[1],
                old_min = min(old_col, na.rm = TRUE),
                old_max = max(old_col, na.rm = TRUE),
                new_min = min(new_col, na.rm = TRUE),
                new_max = max(new_col, na.rm = TRUE),
                old_mean = mean(old_col, na.rm = TRUE),
                new_mean = mean(new_col, na.rm = TRUE),
                old_median = median(old_col, na.rm = TRUE),
                new_median = median(new_col, na.rm = TRUE),
                old_n_na = sum(is.na(old_col)),
                new_n_na = sum(is.na(new_col)),
                range_equal = (min(old_col, na.rm = TRUE) != min(new_col, na.rm = TRUE)) |
                  (max(old_col, na.rm = TRUE) != max(new_col, na.rm = TRUE)),
                mean_equal = !isTRUE(all.equal(mean(old_col, na.rm = TRUE), mean(new_col, na.rm = TRUE))),
                median_equal = !isTRUE(all.equal(median(old_col, na.rm = TRUE), median(new_col, na.rm = TRUE))),
                missingness_equal = sum(is.na(old_col)) != sum(is.na(new_col))
              )
            } else {
              tibble(
                variable = var,
                old_class = class(old_col)[1],
                new_class = class(new_col)[1],
                type_equal = class(old_col)[1] != class(new_col)[1],
                old_min = NA_real_,
                old_max = NA_real_,
                new_min = NA_real_,
                new_max = NA_real_,
                old_mean = NA_real_,
                new_mean = NA_real_,
                old_median = NA_real_,
                new_median = NA_real_,
                old_n_na = sum(is.na(old_col)),
                new_n_na = sum(is.na(new_col)),
                range_equal = NA,
                mean_equal = NA,
                median_equal = NA,
                missingness_equal = sum(is.na(old_col)) != sum(is.na(new_col))
              )
            }
  })

  comparison_tbl <- bind_rows(check_list)

  # Pointblank summary agent (optional)
  agent <-
    create_agent(tbl = comparison_tbl) %>%
    col_vals_not_null(vars(variable)) %>%
    col_vals_equal(vars(type_equal), value = FALSE, brief = "Type changed") %>%
    col_vals_equal(vars(range_equal), value = FALSE, brief = "Range changed") %>%
    col_vals_equal(vars(mean_equal), value = FALSE, brief = "Mean changed") %>%
    col_vals_equal(vars(median_equal), value = FALSE, brief = "Median changed") %>%
    col_vals_equal(vars(missingness_equal), value = FALSE, brief = "Missingness changed")

  agent <- interrogate(agent)

  print(agent)

  return(comparison_tbl)

}



#' Compare Indicators Between Pipeline Versions and Generate Diagnostics
#'
#' This function compares two versions of harmonized pipeline outputs and
#' generates:
#' \itemize{
#'   \item a pointblank validation audit,
#'   \item a table of rows where indicator values changed or were newly added,
#'   \item a year–by–indicator heatmap of \strong{average absolute percentage differences}
#'         across all countries.
#' }
#' It also optionally saves the heatmap to disk.
#'
#' @param old_df A data frame containing the previous pipeline results.
#' @param new_df A data frame containing the new pipeline results.
#' @param plot_save_path Optional file path (including filename) for saving
#'   the heatmap as a PNG. If \code{NULL}, the heatmap is not saved.
#'
#' @return A list with:
#' \itemize{
#'   \item \code{agent} — pointblank validation agent summary
#'   \item \code{difference_table} — rows where indicator values changed or were updated
#'   \item \code{avg_abs_diff} — a data frame of mean absolute percent differences
#'         by indicator and year, averaged across countries
#'   \item \code{heatmap} — the ggplot2 heatmap of average absolute differences
#' }
#'
#' @importFrom dplyr select mutate filter if_all case_when all_of vars group_by summarise n
#' @importFrom tidyr pivot_longer
#' @importFrom pointblank create_agent col_vals_equal col_vals_not_equal interrogate
#' @importFrom ggplot2 ggplot aes geom_tile scale_fill_gradient labs theme_minimal
#' @importFrom ggplot2 theme element_text ggsave scale_y_discrete expansion margin
#'
#' @export
compare_pipeline_indicators <- function(old_df, new_df, plot_save_path = NULL) {

  # Identify common columns
  common_indicators <- setdiff(
    intersect(names(old_df), names(new_df)),
    c("country_code", "year")
  )

  # Reshape both datasets to long
  old_long <-
    old_df %>%
    dplyr::select(country_code, year, dplyr::all_of(common_indicators)) %>%
    tidyr::pivot_longer(
      cols = dplyr::all_of(common_indicators),
      names_to = "indicator",
      values_to = "old_value"
    )

  new_long <-
    new_df %>%
    dplyr::select(country_code, year, dplyr::all_of(common_indicators)) %>%
    tidyr::pivot_longer(
      cols = dplyr::all_of(common_indicators),
      names_to = "indicator",
      values_to = "new_value"
    )

  # Full outer join
  compare_df <-
    merge(old_long, new_long,
          by = c("country_code", "year", "indicator"),
          all = TRUE) %>%
    dplyr::mutate(
      value_equal = old_value == new_value,
      is_update = is.na(old_value) & !is.na(new_value),
      over_1pct_change = dplyr::case_when(
        !is.na(old_value) & !is.na(new_value) & old_value != 0 ~
          abs((new_value - old_value) / old_value) > 0.01,
        TRUE ~ NA
      )
    )

  # -------------------------------------------------------------------
  # POINTBLANK agent
  # -------------------------------------------------------------------
  agent <-
    compare_df %>%
    pointblank::create_agent() %>%
    pointblank::col_vals_equal(
      dplyr::vars(value_equal),
      value = TRUE,
      preconditions = ~ . %>% dplyr::filter(!is.na(old_value) & !is.na(new_value)),
      label = "Check if indicator values changed"
    ) %>%
    pointblank::col_vals_not_equal(
      over_1pct_change, value = TRUE,
      preconditions = ~ . %>% dplyr::filter(!is.na(over_1pct_change)),
      label = "Check if changed values exceed 1% absolute difference"
    ) %>%
    pointblank::col_vals_equal(
      dplyr::vars(is_update),
      value = FALSE,
      preconditions = ~ . %>% dplyr::filter(!is.na(new_value)),
      label = "Check for new data not present in previous pipeline"
    ) %>%
    pointblank::interrogate()

  print(agent)

  # -------------------------------------------------------------------
  # Difference table
  # -------------------------------------------------------------------
  diff_df <-
    compare_df %>%
    dplyr::filter(is_update | !value_equal | is.na(value_equal)) %>%
    dplyr::filter(!dplyr::if_all(c(old_value, new_value, value_equal), is.na))

  if (nrow(diff_df) == 0) {
    message("No indicator updates or changes detected between versions.")
  }

  # -------------------------------------------------------------------
  # NEW: COUNTRY-LEVEL AVERAGE ABSOLUTE DIFFERENCE
  # -------------------------------------------------------------------
  avg_diff_df <-
  compare_df %>%
  dplyr::filter(
    !is.na(old_value),
    !is.na(new_value),
    old_value != 0   # prevent division-by-zero
  ) %>%
  dplyr::mutate(abs_diff = 100 * abs((new_value - old_value) / old_value)) %>%
  dplyr::group_by(indicator, year) %>%
  dplyr::summarise(
    avg_abs_diff = mean(abs_diff, na.rm = TRUE),
    n_countries = dplyr::n(),
    .groups = "drop"
  )

  # -------------------------------------------------------------------
  # NEW: HEATMAP OF AVG ABS DIFF
  # -------------------------------------------------------------------
  # -------------------------------------------------------------------
  # NEW: HEATMAP — INDICATOR × YEAR (AVG ACROSS COUNTRIES)
  # -------------------------------------------------------------------
 # -------------------------------------------------------------------
# NEW: HEATMAP — INDICATOR × YEAR (AVG ACROSS COUNTRIES)
# -------------------------------------------------------------------
heatmap_plot <-
  ggplot2::ggplot(
    avg_diff_df,
    ggplot2::aes(
      x = factor(year),
      y = indicator,
      fill = avg_abs_diff
    )
  ) +
  ggplot2::geom_tile(
    color = "grey20",       # <<< border around tiles
    linewidth = 0.3
  ) +
  ggplot2::scale_fill_gradient(
    low = "white",
    high = "red",
    na.value = "grey90"
  ) +
  ggplot2::scale_y_discrete(
    expand = ggplot2::expansion(mult = 0.15)  
    # <<< dynamically increases vertical spacing
  ) +
  ggplot2::labs(
    title = "Average Absolute % Difference Across Countries",
    x = "Year",
    y = "Indicator",
    fill = "Avg Abs % Diff"
  ) +
  ggplot2::theme_minimal(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 45, hjust = 1),
    plot.margin = ggplot2::margin(15, 15, 15, 25),  
    # <<< prevents clipping of wide y-axis labels
    panel.grid = ggplot2::element_blank(),
    axis.text.y = ggplot2::element_text(size = 9)  
    # <<< slightly smaller text for readability
  )


  # Save plot if path provided
  if (!is.null(plot_save_path)) {
    ggplot2::ggsave(
      plot_save_path,
      heatmap_plot,
      width = 14,
      height = 16
    )
  }

  # -------------------------------------------------------------------
  # Return results
  # -------------------------------------------------------------------
  return(list(
    agent = agent,
    difference_table = diff_df,
    avg_abs_diff = avg_diff_df,
    heatmap = heatmap_plot
  ))
}

#' This quick function will generate the comparison report using the
#' compare_pipeline_indicators() function within a markdown file stored
#' in a temporary location.
#'
#' @keywords internal
#' @noRd
#' @importFrom rmarkdown render
generate_pipeline_comparison_report <- function() {
  tmp_file <- tempfile(fileext = ".html")

  rmarkdown::render(
    input = "inst/qcheck/indicators_compare_pipeline.Rmd",
    output_format = "html_document",
    output_file = tmp_file
  )

  message("Report generated at: ", tmp_file)
  return(tmp_file)
}







